
/**
 * @import {Program} from 'estree-jsx'
 * @import {Root} from 'mdast'
 * @import {Options as RehypeRecmaOptions} from 'rehype-recma'
 * @import {Options as RemarkRehypeOptions} from 'remark-rehype'
 * @import {SourceMapGenerator} from 'source-map'
 * @import {PluggableList, Processor} from 'unified'
 */

/**
 * @typedef ProcessorOptions
 *   Configuration for `createProcessor`.
 * @property {typeof SourceMapGenerator | null | undefined} [SourceMapGenerator]
 *   Add a source map (object form) as the `map` field on the resulting file
 *   (optional).
 * @property {URL | string | null | undefined} [baseUrl]
 *   Use this URL as `import.meta.url` and resolve `import` and `export â€¦ from`
 *   relative to it (optional, example: `import.meta.url`).
 * @property {boolean | null | undefined} [development=false]
 *   Whether to add extra info to error messages in generated code and use the
 *   development automatic JSX runtime (`Fragment` and `jsxDEV` from
 *   `/jsx-dev-runtime`) (default: `false`);
 *   when using the webpack loader (`@mdx-js/loader`) or the Rollup integration
 *   (`@mdx-js/rollup`) through Vite, this is automatically inferred from how
 *   you configure those tools.
 * @property {RehypeRecmaOptions['elementAttributeNameCase']} [elementAttributeNameCase='react']
 *   Casing to use for attribute names (default: `'react'`);
 *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`;
 *   React casing is for example `className`, `strokeLinecap`, `xmlLang`;
 *   for JSX components written in MDX, the author has to be aware of which
 *   framework they use and write code accordingly;
 *   for AST nodes generated by this project, this option configures it
 * @property {'md' | 'mdx' | null | undefined} [format='mdx']
 *   format of the file (default: `'mdx'`);
 *   `'md'` means treat as markdown and `'mdx'` means treat as MDX.
 * @property {boolean | null | undefined} [jsx=false]
 *   Whether to keep JSX (default: `false`);
 *   the default is to compile JSX away so that the resulting file is
 *   immediately runnable.
 * @property {string | null | undefined} [jsxImportSource='astro']
 *   Place to import automatic JSX runtimes from (default: `'astro'`);
 *   when in the `automatic` runtime, this is used to define an import for
 *   `Fragment`, `jsx`, `jsxDEV`, and `jsxs`.
 * @property {'automatic' | 'classic' | null | undefined} [jsxRuntime='automatic']
 *   JSX runtime to use (default: `'automatic'`);
 *   the automatic runtime compiles to `import _jsx from
 *   '$importSource/jsx-runtime'\n_jsx('p')`;
 *   the classic runtime compiles to calls such as `h('p')`.
 *
 *   > ðŸ‘‰ **Note**: support for the classic runtime is deprecated and will
 *   > likely be removed in the next major version.
 * @property {ReadonlyArray<string> | null | undefined} [mdExtensions]
 *   List of markdown extensions, with dot (default: `['.md', '.markdown', â€¦]`);
 *   affects integrations.
 * @property {ReadonlyArray<string> | null | undefined} [mdxExtensions]
 *   List of MDX extensions, with dot (default: `['.mdx']`);
 *   affects integrations.
 * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']
 *   Output format to generate (default: `'program'`);
 *   in most cases `'program'` should be used, it results in a whole program;
 *   internally `evaluate` uses `'function-body'` to compile to
 *   code that can be passed to `run`;
 *   in some cases, you might want what `evaluate` does in separate steps, such
 *   as when compiling on the server and running on the client.
 * @property {string | null | undefined} [pragma='React.createElement']
 *   Pragma for JSX, used in the classic runtime as an identifier for function
 *   calls: `<x />` to `React.createElement('x')` (default:
 *   `'React.createElement'`);
 *   when changing this, you should also define `pragmaFrag` and
 *   `pragmaImportSource` too.
 *
 *   > ðŸ‘‰ **Note**: support for the classic runtime is deprecated and will
 *   > likely be removed in the next major version.
 * @property {string | null | undefined} [pragmaFrag='React.Fragment']
 *   Pragma for fragment symbol, used in the classic runtime as an identifier
 *   for unnamed calls: `<>` to `React.createElement(React.Fragment)` (default:
 *   `'React.Fragment'`);
 *   when changing this, you should also define `pragma` and
 *   `pragmaImportSource` too.
 *
 *   > ðŸ‘‰ **Note**: support for the classic runtime is deprecated and will
 *   > likely be removed in the next major version.
 * @property {string | null | undefined} [pragmaImportSource='react']
 *   Where to import the identifier of `pragma` from, used in the classic
 *   runtime (default: `'react'`);
 *   to illustrate, when `pragma` is `'a.b'` and `pragmaImportSource` is `'c'`
 *   the following will be generated: `import a from 'c'` and things such as
 *   `a.b('h1', {})`.
 *   when changing this, you should also define `pragma` and `pragmaFrag` too.
 *
 *   > ðŸ‘‰ **Note**: support for the classic runtime is deprecated and will
 *   > likely be removed in the next major version.
 * @property {string | null | undefined} [providerImportSource]
 *   Place to import a provider from (optional, example: `'@mdx-js/react'`);
 *   normally itâ€™s used for runtimes that support context (React, Preact), but
 *   it can be used to inject components into the compiled code;
 *   the module must export and identifier `useMDXComponents` which is called
 *   without arguments to get an object of components (`MDXComponents` from
 *   `mdx/types.js`).
 * @property {PluggableList | null | undefined} [recmaPlugins]
 *   List of recma plugins (optional).
 * @property {PluggableList | null | undefined} [remarkPlugins]
 *   List of remark plugins (optional).
 * @property {PluggableList | null | undefined} [rehypePlugins]
 *   List of rehype plugins (optional).
 * @property {Readonly<RemarkRehypeOptions> | null | undefined} [remarkRehypeOptions]
 *   Options to pass to `remark-rehype` (optional);
 *   in particular, you might want to pass configuration for footnotes if your
 *   content is not in English;
 *   the option `allowDangerousHtml` will always be set to `true` and the MDX
 *   nodes (see `nodeTypes`) are passed through.
 * @property {RehypeRecmaOptions['stylePropertyNameCase']} [stylePropertyNameCase='dom']
 *   Casing to use for property names in `style` objects (default: `'dom'`);
 *   CSS casing is for example `background-color` and `-webkit-line-clamp`;
 *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`;
 *   for JSX components written in MDX, the author has to be aware of which
 *   framework they use and write code accordingly;
 *   for AST nodes generated by this project, this option configures it
 * @property {boolean | null | undefined} [tableCellAlignToStyle=true]
 *   Turn obsolete `align` properties on `td` and `th` into CSS `style`
 *   properties (default: `true`).
 */

import { unreachable } from 'devlop'
import recmaBuildJsx from 'recma-build-jsx'
import recmaJsx from 'recma-jsx'
import recmaStringify from 'recma-stringify'
import rehypeRecma from 'rehype-recma'
import remarkMdx from 'remark-mdx'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import { unified } from 'unified'
import { recmaBuildJsxTransform } from './plugin/recma-build-jsx-transform.js'
import { recmaDocument } from './plugin/recma-document.js'
import { recmaJsxRewrite } from './plugin/recma-jsx-rewrite.js'
import { remarkMarkAndUnravel } from './plugin/remark-mark-and-unravel.js'
import { nodeTypes } from './node-types.js'

const removedOptions = [
  'compilers',
  'filepath',
  'hastPlugins',
  'mdPlugins',
  'skipExport',
  'wrapExport'
]

let warned = false

import { VFile } from "vfile"

export default function hastHastify() {
  /** @type {Processor<undefined, undefined, undefined, Root, string>} */
  const self = this

  self.compiler = compiler

  function compiler(tree) {
    return tree
  }
}


const createJsxProcessor = () => {
  const pipelineJsx = unified()
  .use(remarkParse)
  .use(remarkMdx)
  .use(remarkMarkAndUnravel)
  // .use(settings.remarkPlugins || [])
  .use(remarkRehype, {
    // ...remarkRehypeOptions,
    allowDangerousHtml: true,
    // passThrough: [...(remarkRehypeOptions.passThrough || []), ...nodeTypes]
    passThrough: [...nodeTypes]
  })
  .use(hastHastify)

  return pipelineJsx
}

const pipelineJsx = createJsxProcessor()
function jsx2hast(code) {
  const file = new VFile({ value: code })
  const result = pipelineJsx.processSync(file)
  console.log(result.result)
  return result.result
}


export const rehypeTransformJsxInTypst = () => {
  // find all html.elem("script", attrs: ("data-jsx": "import Button from 'Button.jsx;'"))
  // and transform them to html.elem("script", attrs: ("data-jsx": "import Button from 'Button.jsx;'"))
  function compileJsx(node) {
    if (node.type === "element" && node.tagName === "script") {
      let hast = jsx2hast(node.properties["data-jsx"])
      if (!hast) {
        throw new Error("Failed to extract jsx from script")
      }
      hast = hast.children[0]
      console.log("Found jsx, compile to", hast)
      node.properties["data-jsx"] = undefined
      return hast
    }
    if (node.children) {
      node.children = node.children.map(compileJsx)
    }
    return node
  }

  return function (tree, file) {
    return compileJsx(tree)
  }
}

/**
 * Create a processor to compile markdown or MDX to JavaScript.
 *
 * > **Note**: `format: 'detect'` is not allowed in `ProcessorOptions`.
 *
 * @param {Readonly<ProcessorOptions> | null | undefined} [options]
 *   Configuration (optional).
 * @return {Processor<Root, Program, Program, Program, string>}
 *   Processor.
 */
export function createProcessor(options, $typst) {
  const settings = options || {}
  let index = -1

  while (++index < removedOptions.length) {
    const key = removedOptions[index]
    if (key in settings) {
      unreachable(
        'Unexpected removed option `' +
        key +
        '`; see <https://mdxjs.com/migrating/v2/> on how to migrate'
      )
    }
  }

  // @ts-expect-error: throw an error for a runtime value which is not allowed
  // by the types.
  if (settings.format === 'detect') {
    unreachable(
      "Unexpected `format: 'detect'`, which is not supported by `createProcessor`, expected `'mdx'` or `'md'`"
    )
  }

  if (
    (settings.jsxRuntime === 'classic' ||
      settings.pragma ||
      settings.pragmaFrag ||
      settings.pragmaImportSource) &&
    !warned
  ) {
    warned = true
    console.warn(
      "Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate"
    )
  }

  function typ2rehype() {
    // @ts-ignore
    this.parser = parser;

    function parser(_doc, _file) {
      const result = $typst().tryHtml({
        mainFileContent: _file.value
      })
      const hast = result.result?.hast();
      if (!hast) {
        throw new Error("Failed to parse typst")
      }

      console.log(hast)
      return hast;
    }
  }

  let __hast = null;
  function tryParse() {
    // @ts-ignore
    this.parser = parser;
    function parser(_doc, file) {
      return __hast;
    }
  }

  const pipeline = unified()
    .use(tryParse)
    .use(rehypeTransformJsxInTypst)
    .use(settings.rehypePlugins || [])

  pipeline
    .use(rehypeRecma, settings)
    .use(recmaDocument, settings)
    .use(recmaJsxRewrite, settings)

  if (!settings.jsx) {
    pipeline.use(recmaBuildJsx, settings).use(recmaBuildJsxTransform, settings)
  }

  pipeline
    .use(recmaJsx)
    .use(recmaStringify, settings)
    .use(settings.recmaPlugins || [])


  pipeline.__setHast = function (hast) {
    __hast = hast;
  }
  // @ts-expect-error: TS doesnâ€™t get the plugins we added with if-statements.
  return pipeline
}
